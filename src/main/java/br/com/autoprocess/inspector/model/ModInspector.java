package br.com.autoprocess.inspector.model;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import br.com.autoprocess.inspector.bean.Contexto;
import br.com.autoprocess.inspector.bean.ItemCombo;
import br.com.autoprocess.inspector.bean.ItemTabela;
import br.com.autoprocess.inspector.bean.TipoHeader;
import br.com.autoprocess.inspector.main.Inspector;
import br.com.autoprocess.inspector.view.models.TableModel;

public class ModInspector {
	
	private ModFiles modFiles;
	
	public ModInspector() {
		modFiles = new ModFiles();
	}
	
	/**
	 * Recupera a lista de serviços GSI
	 * 
	 * @return
	 */
	public ItemCombo[] getServicesList() {
		
		List<ItemCombo> retorno = new ArrayList<ItemCombo>();
		
		retorno.add(new ItemCombo("Service"));
		
		for (String file : modFiles.getServicesList()) {
			retorno.add(new ItemCombo(file));
		}
		
		return retorno.toArray(new ItemCombo[0]);
		
	}

	/**
	 * Recupera a lista de operações GSI
	 * 
	 * @param servico
	 * @return
	 */
	public ItemCombo[] getOperationsList(String servico) {
		List<ItemCombo> retorno = new ArrayList<ItemCombo>();
		
		retorno.add(new ItemCombo("Operation"));
		
		for (String file : modFiles.getOperationsList(servico)) {
			retorno.add(new ItemCombo(file));
		}

		return retorno.toArray(new ItemCombo[0]);
	}

	/**
	 * Recupera a lista de transações MI
	 * 
	 * @return
	 */
	public ItemCombo[] getTransactionsList() {
		List<ItemCombo> retorno = new ArrayList<ItemCombo>();
		
		retorno.add(new ItemCombo("Transaction"));
		
		for (String file : modFiles.getTransactionsList()) {
			retorno.add(new ItemCombo(file));
		}
		
		return retorno.toArray(new ItemCombo[0]);
	}

	/**
	 * Recupera os itens da tabela
	 * 
	 * @param ctx Indica se a leitura atual é entrada ou saída
	 * @param tipoTransacao Indica se é um serviço GSI ou uma transação MI
	 * @param fileName Nome do arquivo de layout
	 * @param buffer O buffer que contém os dados da transação
	 * @return
	 */
	public TableModel getItensTabela(String fileName, String buffer, TipoHeader tipoTransacao, Contexto ctx) throws Exception {
		
		// ------------------------
		// Carrega do arquivo somente os dados de entrada ou saída
		// ------------------------
		List<String> layout = modFiles.loadLayout(fileName, tipoTransacao, ctx);
		
		// ------------------------
		// Efetua o parser do buffer com o layout
		// ------------------------
		Parser parser = new Parser(layout, buffer);
		
		List<ItemTabela> itens = parser.match();
		
		// ------------------------
		// Adiciona os dados recebidos na tabela
		// ------------------------
		TableModel retorno = new TableModel();
		
		for (ItemTabela i : itens) {
			retorno.addCampo(i);
		}
		
		return retorno;
		
	}
	
	/**
	 * Exporta o buffer e a tabela para um arquivo texto
	 * 
	 * @param buffer
	 * @param dadosTabela
	 * @param file
	 * @throws IOException
	 */
	public void export(String buffer, TableModel dadosTabela, File file, Contexto ctx) throws IOException {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd - HH:mm:ss");
		String quebraLinha = System.getProperty("line.separator");
		
		// ---------------------------
		// Armazena o conteúdo que será escrito no arquivo
		// ---------------------------
		StringBuilder conteudoArquivo = new StringBuilder();
		
		// ---------------------------
		// Adiciona o header do arquivo na saída
		// ---------------------------
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("Generated by " + Inspector.APPLICATION_NAME + quebraLinha);
		conteudoArquivo.append("Context: " + ((ctx == Contexto.ENTRADA) ? "Input" : "Output") + quebraLinha);
		conteudoArquivo.append(dateFormat.format(new Date()) + quebraLinha);
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append(quebraLinha);
		
		// ---------------------------
		// Adiciona o buffer na saída
		// ---------------------------
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("Buffer content" + quebraLinha);
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("["+ buffer +"]");

		// ---------------------------
		// Adiciona o conteúdo da tabela na saída
		// ---------------------------
		if (dadosTabela.getRowCount() > 0) {
			
			conteudoArquivo.append(quebraLinha);
			conteudoArquivo.append(quebraLinha);
			conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
			conteudoArquivo.append("Mapped buffer" + quebraLinha);
			conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
			
			for (int i = 0; i < dadosTabela.getRowCount(); i++) {
				
				ItemTabela item = dadosTabela.getCampo(i);
				
				String nome = formataIdentacaoNome(item.getNome(), item.getNivel());
				String valor = item.getValor();
				
				// ---------------------------
				// Informa que há um erro quando:
				// 	- Houve um erro no parser da linha
				// 	- O tipo é numérico mas existe caracteres não numéricos
				// 	- É a última linha, com o resto do buffer
				// ---------------------------
				if (item.isErro() || (item.getTipo() != null && item.getTipo().equals("N") && !item.getValor().matches("\\d+")) || item.getNome().equals("Remaining content")) {
					nome = "**error** "+ nome;
				}
				
				// ---------------------------
				// Coloca o valor entre colchetes para facilitar a leitura, caso o valor seja diferente de null
				// ---------------------------
				if (valor == null || valor.trim().equals("")) {
					valor = "";
				} else {
					
					// ---------------------------
					// Substitui os pontos que visualmente representam espaços por um espaço real
					// ---------------------------
					valor = "["+ valor.replaceAll("·", " ") +"]";
					
				}
				
				// ---------------------------
				// Adiciona a linha atual na lista de retorno
				// ---------------------------
				conteudoArquivo.append(nome + " " + valor + quebraLinha);
				
			}
			
		}
        
		// ---------------------------
		// Corrige a extensão do arquivo 
		// ---------------------------
		String nomeArquivo = file.getAbsolutePath();
		
		if (!nomeArquivo.toLowerCase().endsWith(".txt")) {
			nomeArquivo = nomeArquivo + ".txt";
			file = new File(nomeArquivo);
		}

		// ---------------------------
		// Cria o arquivo caso não exista
		// ---------------------------
		if (!file.exists()) {
			file.createNewFile();
		}
		
		// ---------------------------
		// Escreve o conteúdo no arquivo
		// ---------------------------
		FileWriter arquivo = new FileWriter(file);
		arquivo.write(conteudoArquivo.toString());
		
		// ---------------------------
		// Fecha o arquivo
		// ---------------------------
		arquivo.close();

	}
	
	private String formataIdentacaoNome(String nome, int nivel) {

		String espacos = "";
		
		if (nivel > 0) {
			for (int i = 0; i < nivel * Inspector.QTD_IDENTACOES; i++) {
				espacos += " ";
			}
		}
		
		return espacos + nome;
	}
	
}
