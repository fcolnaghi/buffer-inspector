package br.com.autoprocess.inspector.model;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.text.Collator;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Scanner;

import br.com.autoprocess.inspector.main.Inspector;
import br.com.autoprocess.inspector.view.TableModel;

public class ModInspector {
	
	/**
	 * Recupera a lista de grupos
	 * 
	 * @return
	 */
	public List<String> getGroups() {
		
		List<String> retorno = new ArrayList<String>();
		
		// ------------------------
		// Carrega o diretorio
		// ------------------------
		File file = new File(getApplicationPath() + "\\interfaces");
		
		// ------------------------
		// Cria o diretorio 'interfaces' caso nao exista
		// ------------------------
		if (!file.exists()) {
			file.mkdir();
		} else {
			
			// ------------------------
			// Lista os diretorios
			// ------------------------
			for (File f : file.listFiles()) {
				if (f.isDirectory()) {
					retorno.add(f.getName());
				}
			}

			// ------------------------
			// Cria um grupo default para os itens que não estão agrupados
			// ------------------------			
			retorno.add(Inspector.DEFAULT_GROUP_NAME);
			
			// ------------------------
			// Ordena a lista
			// ------------------------
			Collections.sort(retorno, Collator.getInstance());
		}

		return retorno;
		
	}

	/**
	 * Recupera as interfaces dentro do grupo selecionado
	 * 
	 * @param grupo
	 * @return
	 */
	public List<String> getInterfaces(String grupo) {
		
		List<String> retorno = new ArrayList<String>();
		
		// ------------------------
		// Carrega o diretorio
		// ------------------------
		File file;
		
		if (Inspector.DEFAULT_GROUP_NAME.equals(grupo)) {
			file = new File(getApplicationPath() + "\\interfaces");
		} else {
			file = new File(getApplicationPath() + "\\interfaces\\" + grupo);
		}
		
		// ------------------------
		// Cria o diretorio caso ele nao exista
		// ------------------------
		for (File f : file.listFiles()) {
			if (!f.isDirectory() && f.getName().endsWith(".txt")) {
				retorno.add(f.getName().split(".txt")[0]);
			}
		}
		
		// ------------------------
		// Ordena a lista
		// ------------------------
		Collections.sort(retorno, Collator.getInstance());
		
		return retorno;

	}

	/**
	 * Recupera os itens da tabela
	 * 
	 * @param ctx Indica se a leitura atual e entrada ou saida
	 * @param tipoTransacao Indica se e um servico GSI ou uma transacao MI
	 * @param fileName Nome do arquivo de layout
	 * @param buffer O buffer que contem os dados da transacao
	 * @return
	 */
	public TableModel getItensTabela(String fileName, String buffer) throws Exception {
		
		// ------------------------
		// Carrega do arquivo somente os dados de entrada ou saida
		// ------------------------
		List<String> layout = loadLayout(fileName);
		
		// ------------------------
		// Efetua o parser do buffer com o layout
		// ------------------------
		Parser parser = new Parser(layout, buffer);
		
		List<ItemTabela> itens = parser.match();
		
		// ------------------------
		// Adiciona os dados recebidos na tabela
		// ------------------------
		TableModel retorno = new TableModel();
		
		for (ItemTabela i : itens) {
			retorno.addCampo(i);
		}
		
		return retorno;
		
	}
	
	/**
	 * Exporta o buffer e a tabela para um arquivo texto
	 * 
	 * @param buffer
	 * @param dadosTabela
	 * @param file
	 * @throws IOException
	 */
	public void export(String buffer, TableModel dadosTabela, File file) throws IOException {
		
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd - HH:mm:ss");
		String quebraLinha = System.getProperty("line.separator");
		
		// ---------------------------
		// Armazena o conteudo que sera escrito no arquivo
		// ---------------------------
		StringBuilder conteudoArquivo = new StringBuilder();
		
		// ---------------------------
		// Adiciona o header do arquivo na saida
		// ---------------------------
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("Generated by " + Inspector.APPLICATION_NAME + quebraLinha);
		conteudoArquivo.append(dateFormat.format(new Date()) + quebraLinha);
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append(quebraLinha);
		
		// ---------------------------
		// Adiciona o buffer na saida
		// ---------------------------
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("Buffer content" + quebraLinha);
		conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
		conteudoArquivo.append("["+ buffer +"]");

		// ---------------------------
		// Adiciona o conteï¿½do da tabela na saida
		// ---------------------------
		if (dadosTabela.getRowCount() > 0) {
			
			conteudoArquivo.append(quebraLinha);
			conteudoArquivo.append(quebraLinha);
			conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
			conteudoArquivo.append("Mapped buffer" + quebraLinha);
			conteudoArquivo.append("---------------------------------------------------------------------------" + quebraLinha);
			
			for (int i = 0; i < dadosTabela.getRowCount(); i++) {
				
				ItemTabela item = dadosTabela.getCampo(i);
				
				String nome = formataIdentacaoNome(item.getNome(), item.getNivel());
				String valor = item.getValor();
				
				// ---------------------------
				// Informa que ha um erro quando:
				// 	- Houve um erro no parser da linha
				// 	- O tipo e numerico mas existe caracteres nao numericos
				// 	- e a ultima linha, com o resto do buffer
				// ---------------------------
				if (item.isErro() || (item.getTipo() != null && item.getTipo().equals("N") && !item.getValor().matches("\\d+")) || item.getNome().equals("Remaining content")) {
					nome = "**error** "+ nome;
				}
				
				// ---------------------------
				// Coloca o valor entre colchetes para facilitar a leitura, caso o valor seja diferente de null
				// ---------------------------
				if (valor == null || valor.trim().equals("")) {
					valor = "";
				} else {
					
					// ---------------------------
					// Substitui os pontos que visualmente representam espacos por um espaco real
					// ---------------------------
					valor = "["+ valor.replaceAll("ï¿½", " ") +"]";
					
				}
				
				// ---------------------------
				// Adiciona a linha atual na lista de retorno
				// ---------------------------
				conteudoArquivo.append(nome + " " + valor + quebraLinha);
				
			}
			
		}
        
		// ---------------------------
		// Corrige a extensao do arquivo 
		// ---------------------------
		String nomeArquivo = file.getAbsolutePath();
		
		if (!nomeArquivo.toLowerCase().endsWith(".txt")) {
			nomeArquivo = nomeArquivo + ".txt";
			file = new File(nomeArquivo);
		}

		// ---------------------------
		// Cria o arquivo caso nao exista
		// ---------------------------
		if (!file.exists()) {
			file.createNewFile();
		}
		
		// ---------------------------
		// Escreve o conteudo no arquivo
		// ---------------------------
		FileWriter arquivo = new FileWriter(file);
		arquivo.write(conteudoArquivo.toString());
		
		// ---------------------------
		// Fecha o arquivo
		// ---------------------------
		arquivo.close();

	}
	
	private String formataIdentacaoNome(String nome, int nivel) {

		String espacos = "";
		
		if (nivel > 0) {
			for (int i = 0; i < nivel * Inspector.QTD_IDENTACOES; i++) {
				espacos += " ";
			}
		}
		
		return espacos + nome;
	}
	
	/**
	 * Carrega os dados do arquivo de layout (entrada ou saï¿½da) em uma lista de Strings
	 * 
	 * @param arquivoLayout O nome do arquivo de layout
	 * @param ctx Indica se e entrada ou saida
	 * @return
	 */
	public List<String> loadLayout(String fileName) throws Exception {

		List<String> retorno = new ArrayList<String>();
		
		// ------------------------
		// Abre o arquivo de layout
		// ------------------------
		if (fileName.startsWith(Inspector.DEFAULT_GROUP_NAME)) {
			fileName = fileName.substring((Inspector.DEFAULT_GROUP_NAME.length() + 1), fileName.length());
		}
		
		File file = new File(getApplicationPath() + "\\interfaces\\" + fileName + ".txt");			
		
		// ------------------------
		// Le o conteudo do arquivo
		// ------------------------
		Scanner linhas = null;
		
		try {
			linhas = new Scanner(file);

			// ------------------------
			// Armazena o numero da linha do arquivo
			// ------------------------
			int i = 1;
			
			// ------------------------
			// Transfere o conteudo do arquivo para a variavel de retorno
			// ------------------------
			while (linhas.hasNext()) {
				
				// ------------------------
				// Efetura a leitura da linha atual
				// ------------------------
				String linha = linhas.nextLine();
				
				// ------------------------
				// Retira espaï¿½os desnecessarios e transforma o conteudo para caixa alta
				// ------------------------
				linha = linha.trim();
				
				// ------------------------
				// Le o conteudo do arquivo atraves de seu tipo (entrada/saida), desconsiderando comentarios
				// ------------------------
				if (!linha.isEmpty() && !linha.startsWith("#") && !linha.startsWith(";") && !linha.startsWith("/")) {
					retorno.add(i + ";" + linha);
				}

				i++;
			}
		} catch (Exception e) {
			throw e;
		} finally {
			linhas.close();
		}
		
		return retorno;
	}
	
	/**
	 * Retorna o caminho onde a aplicacao esta sendo executada
	 * 
	 * @return caminho da aplicacao
	 */
	public String getApplicationPath() {
		
		String path = "";
		
		String url = getClass().getResource(getClass().getSimpleName() + ".class").getPath();
		
		File file = new File(url).getParentFile();

		// ------------------------
		// Retorna o caminho quando a aplicacao esta dentro de um arquivo .jar
		// ------------------------
		if (file.getPath().contains(".jar")) {
			
			while (file.getPath().contains(".jar")) {
				file = file.getParentFile();
			}
			
			path = file.getPath().substring(6);
		} else {
			path = file.getPath();
		}

		try {
			return URLDecoder.decode(path, "UTF-8");
		} catch (UnsupportedEncodingException e) {
			return path.replace("%20", " ");
		}
		
	}
	
}
